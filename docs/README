README for orchestrator v0.76

==============
 INTRODUCTION
==============

'orchestrator' is an orchestration application that tries to optimize real-time scheduled container allocation. Its function is to maintain schedulability and determinism while reducing resource requirements by reorganizing allocations and reconfigure the run-time environment based on heuristic and/or statistical data, and run-time evaluations.

The code is currently maintained on GitHub:

	git@github.com:flhofer/real-time-containers.git

And mirrored on the Siemens CODE GitLab installation

	git@code.siemens.com:martin.sehr/real-time-containers.git

The static version limits to configured allocation and does not reschedule processes once a slot has been allocated. For dynamic allocation.

==============
 REQUIREMENTS
==============

'orchestrator' runs on GNU/Linux compliant systems with 'BusyBox' (Musl is not completely supported yet). It needs GNU 'make' and a recent compiler (tested on: gcc) for basic features with the following development packages for compilation:
* libnuma-dev	(NUMA manipulation)
* libcap-dev		(POSIX Capabilities library)
* check			(CHECK C based runtime test framework)
* libsubunit-dev	(CHECK sub-unit export library)
* libjson-c-dev	(JSON configuration parsing)
* libgsl-dev		(Heuristics - GNU scientific library)
* libgsl-dbg		(Heuristics - for dev only)

==================================
 BUILDING AND INSTALLING orchestrator
==================================

The source code package contains three sources: orchestrator, check test framework and use case simulation package.
For standard build configuration of the orchestrator only, run 

$ make

There is no automated system-dependent configuration yet. If you want to enable debug symbols and highly verbose outputs, set the DEBUG parameter, as follows: 

$ make DEBUG=1

Similarly, for the test framework, to compile type

$ make check

alternatively with DEBUG, type

$ make check DEBUG=1

or replace check with 'usecase' for the use case build. No installation procedure is defined at the moment. A further parameter that can be passed during compile is COVERAGE=1, which enables coverage test and output. With 'make all', all of the three builds are executed at once. Finally, the 'make test' option executes the unit tests of the check framework.,

For a reference on how to run specific unit tests only (environment variables CK_RUN_SUITE, CK_RUN_CASE, and CK_NO_FORK) refer to the check user manual. https://libcheck.github.io/check/doc/check_html/check_4.html

=======
 USAGE
=======

Options available as of this version

    $ ./orchestrator [-a <affinity range> -A -b -B -c <clock> -C <cgroup> -d -D -f -F -i <scan interval> -k -l <loop count> -m -n [cmd signature] -p <priority> --policy=<name> -P -q -r <runtime> --rr=<rr-slice-size> -s [container cmd signature] -S [Alg-NR] --smi -v -w <WCET>] [configuration-file]

where:
* affinity range defines the CGroup separation for RT and nRT tasks, 0-(x-1), and x-CPUs. The affinity range can be specified as comma-separated list and ranges, e.g. "0,4,7-10";
* -A denotes the adaptive algorithm, selected if set. The algorithm is an extension of static scheduling techniques, where unallocated, known, containers are placed on a best-fit basis on the available resources;
* -b enables binding of non-real-time tasks to the same core as the real-time task of the container; used for PID based modes;
* -B enables the blind run option, such that the pre-run setup environment does not try to force any run-time environment change.
* clock is the type of clock timer used for recurring threads; The default is the monotonic system clock;
* -C sets the CGroup based container detection mode. By default, the CGroup is set to 'docker/'. When changing, remind ending the group name with a slash;
* -d enables the setting deadline overflow flag for all real-time deadline scheduled tasks; This permits the task to reclaim possible unused real-time bandwidth beyond the allotted amount.
* -D sets the dry-run flag. No kernel or environment parameters will be changed but only actual values reported.
* -f forces execution, even if parameters are seen as risky, and enables changes that might influence other services on the system.
* -F enables kernel function trace-based run-time statistics instead of scheduler debug. The latter is limited to a run-time refresh of 10ms.
* interval is the update interval set for refresh and running statistics. It influences the reactivity of PID based detection modes and changes the overhead amount.
* with the flag -k the data of PIDs that leave will be kept in memory, for statistical purposes only.
* loop count is the number of update loops until the presence of new containers is verified checked (not true for docker-link); 
* -m enables memory page locking, reducing page-fault induced delays.
* -n defines the command line signature detection mode. An optional parameter may be given to specify the base command to look for, e.g. 'rt-app' if looking for instances of rt-app
* the policy and the priority refer to the parameters applied to the metric update thread; available options: other, normal, batch, idle, deadline, fifo, or rr.
* -P, in case command line signature, is set, enables also child-thread detection. Useful if the process is not RT, but the thread is
* -q reduces verbosity where possible
* a maximum runtime can be set with the r flag, in seconds. The default value is 0=unlimited
* with the -rr flag the slice value for Round-Robin scheduled tasks can be changed at startup.
* -s defines the parent PID <shim> signature detection mode; an optional parameter may be given to specify the container daemon to look for, e.g. 'docker-containerd-shim' if looking for instances of Docker containers;
* -S selects the algorithm for the dynamic system scheduler (DSS). This scheduler tries to move containers when an overrun is imminent (Adaptive and Static do not do this). Montecarlo is not implemented yet.
* --smi enables interrupt counters to be read for each CPU. This to track the effect of uncontrollable interrupts;
* -v adds verbosity if the binary has been compiled with the DEBUG flag
* -w details the worst-case execution time needed for the deadline based scheduling of the metric update thread.
The configuration file specified is optional. By default 'config.json' will be used.

===============
 CONFIGURATION
===============

'orchestrator' reads a configuration file to determine the parameters and resources to assign to each container. The default filename is set to 'config.json' and the file follows strict JSON data representation. The file is usually found in the local working directory.
The configuration file settings for this version consists of multiple sections and objects. These objects are connected in a hierarchy and can be present at different levels. The simplest is a PID configuration object. Its layout is as follows:

{  								
	"cmd" : "rt-app conf2.json",// process run signature identification, full or partial
	"params" : {				// real-time parameters - optional
		"policy" : "SCHED_OTHER",// required scheduling policy
		"flags"  : 0,			// process flags -> inheritance
		"nice"   : 0,			// niceness factor for CFS schedules
		"prio"   : 0,			// priority for RT schedules, FIFO & RR
		"runtime": 1000000,		// EDF runtime in us
		"deadline": 4000000,	// EDF deadline in us
		"period" : 4000000		// EDF period in us
	},
	"res" : {					// resouces to allocate for process, optional
		"affinity" : -1,		// CPU affinity, -1 = all 
		"rt-soft" : -1,			// real-time soft limit, execution time -> SIGXCPU
		"rt-hard" : -1,			// real-time hard limit, execution time -> SIGKILL
		"data-soft" : -1, 		// data/heap soft limit
// -> not used	"data-hard" : -1,		// data/heap hard limit
	},
},

The next object in the hierarchy is a container. It is similar to a PID configuration.

{  								
	"contid" : "4efcb6c965de",	// full or partial (at least 12 characters) of container id
	"params" : { ... },			// real-time parameters - optional
	"res" : { ... },			// resouces to allocate for process, optional
	"pids" : [{ ... }],			// list of PID objects for this container
},

An image configuration, again, is similar

{  								
	"imgid" : "1ede341dace5",	// full or partial (at least 12 characters) of img id
	"params" : { ... }, 		// real-time parameters - optional
	"res" : { ... },			// resouces to allocate for process, optional
	"cont" : [{ ... }],			// list of containers that are based on this image
	"pids" : [{ ... }],			// list of default PID objects for this image
},

All these objects are part of a global configuration. This configuration permits to set all settings for the program as well as specifying all the details above.

{

	"global" : {
		"logdir" : "./",						// logging directory - TODO
		"log_basename" : "orchestrator.txt",	// logging basename - TODO
		"prc_kernel" : "/proc/sys/kernel/",		// kernel settings vfs
		"sys_cpuset" : "/sys/fs/cgroup/cpuset/",// cgroup cpuset vfs
		"sys_cpu" :	"/sys/devices/system/cpu/", // cpu settings, ol vfs
		"cont_ppidc" : "containerd-shim",		// pid comm signature for container shim
		"cont_pidc" : "",						// pid comm signature, opt, for filtering
		"cont_cgrp" : "docker/",				// subdirectory in cgroups where containers are
		"priority" : 0,							// priority of update thread
		"clock" : 0,							// clock type to use for delays (not in deadline)
		"default_policy" : "SCHED_OTHER",		// scheduling policy for update thread
		"quiet" : 0, 							// quiet mode
		"affother" : 0,							// tie non-RT tasks to same settings
		"setdflag" : 0,							// sed dl-overrun flag for deadline tasks
		"interval" : 5000,						// update scan interval in us
		"dl_wcet": 100,							// runtime budget for update thread (deadline)
		"loops" : 100,							// number of loops bf checking for new containers
		"runtime" : 0,							// max runtime, 0 = infinite
		"psigscan" : 0, 						// parent signature scan 
		"trackpids" : 0,						// keep left pids in stat
		"lock_pages" : 0,						// lock pages (memory) for orchestrator
		"smi" : 0,								// smi optimizations - TODO
		"rrtime" : 100,							// slice time for rr scheduling, 100us
		"use_fifo" : 0,							// use fifo status output - TODO
		"setaffinity" : "AFFINITY_UNSPECIFIED", // affinity area for containers *_UNSPECIFIED, _SPECIFIED and _USEALL
		"affinity" : "1-2",						// cpu affinity for containers, coma separated cpu list
		"gnuplot" : 0,							// print gnuplot of statistics - TODO
		"logsize" : 0,							// log size in mb - TODO
		"ftrace" : 0,							// enable kernel tracing - TODO
	}

	"images" : [						// list of images with matching containers and pds
	{  								
		"imgid" : "4efcb6c965de",	// full or partial (at least 12 characters) of img id
		"params" : { ... }, 		// real-time parameters - default to globals
		"res" : { ... },			// resouces to allocate for image, default to globals

		"cont" : [					// list of containers that are based on this image
		{  								
				"contid" : "4efcb6c965de",	// full or partial (at least 12 characters) of container id
				"params" : { ... },	// real-time parameters, default to image
				"res" : { ... },	// resouces to allocate, default to image
				"pids" : [{ 
					"cmd" : "rt-app conf2.json",
					"params" : { ... },	// real-time parameters, default to container
					"res" : { ... },	// resouces to allocate, default to container
				 }],	// list of PID objects for this container
		}, ... ],

		"pids" : [ 				// list of default PID objects for this image
		{
			"cmd" : "rt-app conf2.json",
			"params" : { ... },	// real-time parameters, default to image
			"res" : { ... },	// resouces to allocate, default to image
		}, ... ],

	}, ... ],

	"containers" : [					// list of containers that are not based on known image
	{  								
		"contid" : "4efcb6c965de",	// full or partial (at least 12 characters) of container id
		"params" : { ... },			// real-time parameters, defaults to global
		"res" : { ... },			// resouces to allocate for container, defaults to global
		"pids" : [{ ... }],			// list of PID objects for this container
	}, ... ],

	"pids" : [ 						// list of PID objects we dont know container or image
	{
		... 
	}, ... ],

	"scheduling" : {			// real-time parameters for global defaults
		...
	},
	"resources" : {				// resouces to allocate for global defaults
		...
	},
}

This hierarchical setting allows thus specifying:
* image specific settings and running PIDs of that image, valid for all containers using that image
* exceptions to containers, changing settings for a few examples
* exceptions and additions in the PID-list of the image

OR

* container specific settings and running PIDs, without knowing the image name

OR

* PID specific settings, if we know neither the image nor the container, or if we want to apply certain settings to all instances of a PID in all containers

The lookup hierarchy for PIDs is as follows: 

1)	image->container->pid	, if not found
2)	image->pid				, if not found
3)	pid						, if not found
4)	left unchanged

Depending on the use of the software, the fields might be needed or not. The parameters and resource affinity may in some cases be complementary. For example, if the scheduling is done statically on entry events, based on available resources, the "params" settings might be used to allocate the best slot. (* feature in development, quasi static allocation *)
Affinity might be a limiting factor as long as it is a single CPU setting.

=============
 EXAMPLE RUN
=============

The following command presents a possible running scenario:

	$ ./orchestrator -n rt-app -P -b -a 1-3 --policy=deadline -i 5000

In this case, the orchestrator will read the 'config.json' file in the local directory and then scan for containers. The scan will look for processes starting with command 'rt-app' and verify also all their threads. All threads running in a container will be bound to the same affinity range, set up as 1-3. The scan will be performed with a periodicity of 5ms scheduled as a SCHED_DEADLINE task. Every 100 scan cycles the orchestrator will look for new containers to realign.
All other parameters are left default.

