\documentclass[]{scrartcl}

%opening
\title{Investigation on possibilities of scheduling manipulation}
\author{Florian Hofer}

\begin{document}

\maketitle

%\begin{abstract}
%
%\end{abstract}

\section{Environment}

Containers are run, started either by runc or dockerrun, and initialized if configured with an init thread as process 1. 
The new container has a different pid space and userspace
separate mount points for volumes. docker we can specify --pid=host to set to a shared userspace.

\subsection{POSIX Standard}

The IEEE Std 1003.1 defines the interface every compliant operating system must have. The standard also forsees, in addition to the main process management features, an optional X/Open System Interfaces XSI conformace.
The constants that define the presence and function of such interfaces might be found in the <unistd.h> header file. 
The values can be directly interrogated by verifying the constant as described in the standard.
XSI defines in particular three option groups: encryption, realtime (threads) and advanced realtime (threads). 

as verified, only a few of the advanced realtime features are available. 
The conditional compiler flags might be used in the sourcecode for a more detailed outputs. 

\section{PID namespaces}

Before considering option of sharing PID space with host, see if we can access from a privileged container nonetheless the namespace isolation. 
Posix defines functions ioctrl\_ns to determine the parent namespace of the actual one. can help getting the inode of a parent namespace and read information. 
if pids can also be read is a matter of investigation. maybe mount as \/procext?

what information can be read out from the pid is still to be investigated.

Manuals say that a parent can read child namespaces but not vice-versa. All enquiries of pared pid in fact once reached pid 1 (must not be 1 for a container) end up with a 0 response.

\section{PID information}

While in UNIX the PID table and information is part of the kernel memory, in linux the only way to access the process information is by parsing virtual files. 
If the orchestrator has to run on both systems, the PID retrieval must thus be implemented twice. Once via /proc pipe readout and once via sysctrl calls to read kernel memory.

It is highly likely that the same is true for the other resources, such as memory or connectivity. 

An example code has been tested which gives the PID's of all matching process names. 
It might therefore be possible to poll once and verify cyclically for unbound containers. 

In a second moment a hook-like structure might be more convenient.


\section{Other considerations}

During the exploration of the namespace and pid function, some features to be implemented in future where discovered. 
The PID 1 inside the container is parent of all the namespace. If it dies, all the children are orphaned and will be killed. As parent, it is also target of sigs without implicit binding, thus it must manually handle incoming signals such as sig\_int.
The userspace in the container can be mapped. To avoid root as well as other acesses from to.. a proper map should be set up and incorporated in all the containers at load.


\end{document}
